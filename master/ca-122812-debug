diff --git a/drivers/net/xen-netback/interface.c b/drivers/net/xen-netback/interface.c
index b1ec0dc..37c47cd 100644
--- a/drivers/net/xen-netback/interface.c
+++ b/drivers/net/xen-netback/interface.c
@@ -100,6 +100,8 @@ static irqreturn_t xenvif_rx_interrupt(int irq, void *dev_id)
 	struct xenvif *vif = dev_id;
 
 	vif->rx_event = true;
+	mb();
+
 	xenvif_kick_thread(vif);
 
 	return IRQ_HANDLED;
@@ -144,6 +146,7 @@ static int xenvif_start_xmit(struct sk_buff *skb, struct net_device *dev)
 		xenvif_stop_queue(vif);
 
 	skb_queue_tail(&vif->rx_queue, skb);
+
 	xenvif_kick_thread(vif);
 
 	return NETDEV_TX_OK;
@@ -423,6 +426,11 @@ int xenvif_connect(struct xenvif *vif, unsigned long tx_ring_ref,
 
 	vif->task = task;
 
+	vif->rx_event =true;
+	mb();
+
+	xenvif_kick_thread(vif);
+
 	rtnl_lock();
 	if (!vif->can_sg && vif->dev->mtu > ETH_DATA_LEN)
 		dev_set_mtu(vif->dev, ETH_DATA_LEN);
diff --git a/drivers/net/xen-netback/netback.c b/drivers/net/xen-netback/netback.c
index 5a10c51..963f5d9 100644
--- a/drivers/net/xen-netback/netback.c
+++ b/drivers/net/xen-netback/netback.c
@@ -489,7 +489,9 @@ static void xenvif_rx_action(struct xenvif *vif)
 		 * slots we'll use.
 		 */
 
-		max_slots_needed = DIV_ROUND_UP(skb_headlen(skb), PAGE_SIZE);
+		max_slots_needed = DIV_ROUND_UP(offset_in_page(skb->data) +
+						skb_headlen(skb),
+						PAGE_SIZE);
 		for (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {
 			unsigned int size;
 			size = skb_frag_size(&skb_shinfo(skb)->frags[i]);
@@ -502,6 +504,7 @@ static void xenvif_rx_action(struct xenvif *vif)
 		/* If the skb may not fit then bail out now */
 		if (!xenvif_rx_ring_slots_available(vif, max_slots_needed)) {
 			skb_queue_head(&vif->rx_queue, skb);
+			need_to_notify = 1;
 			break;
 		}
 
@@ -515,7 +518,7 @@ static void xenvif_rx_action(struct xenvif *vif)
 	BUG_ON(npo.meta_prod > ARRAY_SIZE(vif->meta));
 
 	if (!npo.copy_prod)
-		return;
+		goto done;
 
 	BUG_ON(npo.copy_prod > ARRAY_SIZE(vif->grant_copy_op));
 	gnttab_batch_copy(vif->grant_copy_op, npo.copy_prod);
@@ -592,6 +595,7 @@ static void xenvif_rx_action(struct xenvif *vif)
 		dev_kfree_skb(skb);
 	}
 
+done:
 	if (need_to_notify)
 		notify_remote_via_irq(vif->rx_irq);
 }
@@ -1738,12 +1742,18 @@ err:
 
 void xenvif_stop_queue(struct xenvif *vif)
 {
-	if (vif->can_queue)
-		netif_stop_queue(vif->dev);
+	if (!vif->can_queue)
+		return;
+
+	netdev_printk(KERN_INFO, vif->dev, "stopping queue\n");
+
+	netif_stop_queue(vif->dev);
 }
 
 static void xenvif_start_queue(struct xenvif *vif)
 {
+	netdev_printk(KERN_INFO, vif->dev, "starting queue\n");
+
 	if (xenvif_schedulable(vif))
 		netif_wake_queue(vif->dev);
 }
@@ -1751,7 +1761,6 @@ static void xenvif_start_queue(struct xenvif *vif)
 int xenvif_kthread(void *data)
 {
 	struct xenvif *vif = data;
-	const int threshold = XEN_NETIF_RX_RING_SIZE / 2;
 	struct sk_buff *skb;
 
 	while (!kthread_should_stop()) {
@@ -1761,11 +1770,14 @@ int xenvif_kthread(void *data)
 		if (kthread_should_stop())
 			break;
 
+		vif->rx_event = false;
+		mb();
+
 		if (!skb_queue_empty(&vif->rx_queue))
 			xenvif_rx_action(vif);
 
-		vif->rx_event = false;
-		if (xenvif_rx_ring_slots_available(vif, threshold))
+		if (skb_queue_empty(&vif->rx_queue) &&
+		    netif_queue_stopped(vif->dev))
 			xenvif_start_queue(vif);
 
 		cond_resched();
