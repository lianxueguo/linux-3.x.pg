# HG changeset patch
# Parent 64b7dc6739b0268ef44b5acb537736a06ae7c51e

diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
index 98a442d..a62dca4 100644
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -517,4 +517,14 @@ source "drivers/misc/lis3lv02d/Kconfig"
 source "drivers/misc/carma/Kconfig"
 source "drivers/misc/altera-stapl/Kconfig"
 source "drivers/misc/mei/Kconfig"
+
+config UKLOG
+	tristate "User level printk support through procfs"
+	depends on PROC_FS
+	default n
+	help
+	  This option exports kernel printk functionality through
+	  procfs to aid in logging in a pre-syslog environment. Only
+	  root may log using this functionality
+
 endmenu
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index b88df7a..8e46d40 100644
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -50,3 +50,4 @@ obj-y				+= carma/
 obj-$(CONFIG_USB_SWITCH_FSA9480) += fsa9480.o
 obj-$(CONFIG_ALTERA_STAPL)	+=altera-stapl/
 obj-$(CONFIG_INTEL_MEI)		+= mei/
++obj-$(CONFIG_UKLOG)		+= uklog.o
diff --git a/drivers/misc/uklog.c b/drivers/misc/uklog.c
new file mode 100644
index 0000000..79ab056
--- /dev/null
+++ b/drivers/misc/uklog.c
@@ -0,0 +1,136 @@
+#include <linux/kernel.h>  /* because this is a kernel module */
+#include <linux/module.h>  /* for module macros */
+#include <linux/init.h>    /* for __init and __exit */
+#include <linux/proc_fs.h> /* for procfs interaction */
+#include <linux/slab.h>    /* for kmalloc() */
+#include <asm/uaccess.h>   /* for copy_from_user */
+
+/* some tweakable parameters which would otherwise be defines */
+static const char * UKLOG_DIRNAME = "printk";
+static const unsigned long TRUNC_SIZE = 1023;
+
+/* enumeration to stick in the data entry so we can use one single proc_write for all
+   exported procfs files */
+enum LEVEL { ALERT,
+	     CRIT,
+	     ERR,
+	     WARNING,
+	     NOTICE,
+	     INFO,
+	     DEBUG };
+
+static struct proc_dir_entry *printk_dir;
+static struct proc_dir_entry *alert, *crit, *err, *warning, *notice, *info, *debug;
+
+int uklog_printf(struct file* file, const char* buffer, unsigned long count, void* data)
+{
+	char * local = NULL;
+	size_t copy_count = 0;
+	
+	/* truncate long requests because log buffer space is limited */
+	copy_count = count < TRUNC_SIZE ? count : TRUNC_SIZE;
+
+	if(NULL == (local = kmalloc(copy_count+1, GFP_KERNEL)))
+		{
+			return -ENOMEM;
+		}
+
+	if(copy_from_user(local, buffer, copy_count))
+		{
+			kfree(local);
+			return -EFAULT;
+		}
+	local[copy_count] = 0;
+
+	/* Because this macro makes it just so much nicer to read... */
+#define CASE(level) case level: { printk(KERN_##level "%s", local); break; }
+
+	switch((unsigned long)data)/* this is safe as we are just using data as an integer flag*/
+		{
+			CASE(ALERT);
+			CASE(CRIT);
+			CASE(ERR);
+			CASE(WARNING);
+			CASE(NOTICE);
+			CASE(INFO);
+			CASE(DEBUG);
+		default:
+			{
+				printk("%s", local);
+				break;
+			}
+		}
+
+#undef CASE
+
+	kfree(local);
+	return count; /* we truncate long messages to save log buffer space so pretend we 
+			 delt with it all */
+}
+
+static int __init uklog_init(void)
+{
+	int rv = 0;
+	
+	printk_dir = proc_mkdir(UKLOG_DIRNAME, NULL);
+	if(NULL == printk_dir)
+		{
+			rv = -ENOMEM;
+			goto out;
+		}
+
+	/* This macro makes the code look far nicer.  It attempts to make a proc_entry
+	   for var, sets its data field to level and assignes its write_proc correctly
+	   On failure, it tares down what is currently set up.
+	 */
+#define SET_UP(var, level) \
+	(var) = create_proc_entry(#var, 0200, printk_dir); \
+	if(NULL == (var)){ \
+		rv = -ENOMEM; \
+		goto no_##var; \
+	} (var)->data=(void*)(level); \
+	(var)->write_proc=uklog_printf;
+
+	SET_UP(alert, ALERT);
+	SET_UP(crit, CRIT);
+	SET_UP(err, ERR);
+	SET_UP(warning, WARNING);
+	SET_UP(notice, NOTICE);
+	SET_UP(info, INFO);
+	SET_UP(debug, DEBUG);
+#undef SET_UP
+
+	/* We are all done setting up so return now and skip the tare down */
+	return 0;
+
+#define TARE_DOWN(var) remove_proc_entry(#var, printk_dir); no_##var:
+ no_debug: /* We never need to remove this proc entry as it is the final setup stage */
+	TARE_DOWN(info);
+	TARE_DOWN(notice);
+	TARE_DOWN(warning);
+	TARE_DOWN(err);
+	TARE_DOWN(crit);
+	TARE_DOWN(alert);
+	remove_proc_entry(UKLOG_DIRNAME, NULL);
+ out:	return rv;
+#undef TARE_DOWN
+}
+
+static void __exit uklog_exit(void)
+{
+	remove_proc_entry("debug", printk_dir);
+	remove_proc_entry("info", printk_dir);
+	remove_proc_entry("notice", printk_dir);
+	remove_proc_entry("warning", printk_dir);
+	remove_proc_entry("err", printk_dir);
+	remove_proc_entry("crit", printk_dir);
+	remove_proc_entry("alert", printk_dir);
+	remove_proc_entry(UKLOG_DIRNAME, NULL);
+}
+
+module_init(uklog_init);
+module_exit(uklog_exit);
+
+MODULE_AUTHOR("Andrew Cooper <andrew.cooper3@citrix.com>");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Exports printk via /proc/printk/* for logging in a pre-syslog environment");
