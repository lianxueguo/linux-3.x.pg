[PATCH] : Hotplug new memory without prepopulation.

This patch enables hotplugging of additional memory without initializing 
it with mfn. Instead the pfns are intialized with INVALID_P2M_ENTRY.
This change enables alloc_xenballooned_pages() API, inherently called
from network and blk backend, to utlize the hotplugged memory for 
servicing backends memory requests from the newly hotplugged memory.
diff --git a/drivers/xen/balloon.c b/drivers/xen/balloon.c
index cac9711..80cd01c 100644
--- a/drivers/xen/balloon.c
+++ b/drivers/xen/balloon.c
@@ -207,10 +207,14 @@ static enum bp_state update_schedule(enum bp_state state)
 }
 
 #ifdef CONFIG_XEN_BALLOON_MEMORY_HOTPLUG
+
+static DECLARE_WAIT_QUEUE_HEAD(balloon_online_wq);
+static unsigned long balloon_nr_hotplug_pages;
+static unsigned long balloon_nr_online_pages;
+
 static long current_credit(void)
 {
-	return balloon_stats.target_pages - balloon_stats.current_pages -
-		balloon_stats.hotplug_pages;
+	return balloon_stats.target_pages - balloon_stats.current_pages;
 }
 
 static bool balloon_is_inflated(void)
@@ -222,6 +226,48 @@ static bool balloon_is_inflated(void)
 		return false;
 }
 
+static struct resource *additional_memory_resource(phys_addr_t size)
+{
+	struct resource *res;
+	int ret;
+	unsigned long pfn;
+
+	res = kzalloc(sizeof(*res), GFP_KERNEL);
+	if (!res)
+		return NULL;
+
+	res->name = "System RAM";
+	res->flags = IORESOURCE_MEM | IORESOURCE_BUSY;
+
+	ret = allocate_resource(&iomem_resource, res,
+				size, 0, -1,
+				PAGES_PER_SECTION * PAGE_SIZE, NULL, NULL);
+	if (ret < 0) {
+		pr_err("Cannot allocate new System RAM resource\n");
+		kfree(res);
+		return NULL;
+	}
+
+	for (pfn = PFN_DOWN(res->start);
+	     pfn < PFN_DOWN(res->end); pfn++)
+    {
+		set_phys_to_machine(pfn, INVALID_P2M_ENTRY);
+    }
+
+	return res;
+}
+
+static void release_memory_resource(struct resource *resource)
+{
+	if (!resource)
+		return;
+
+	/* FIXME: resource identity p2m? */
+
+	release_resource(resource);
+	kfree(resource);
+}
+
 /*
  * reserve_additional_memory() adds memory region of size >= credit above
  * max_pfn. New region is section aligned and size is modified to be multiple
@@ -235,27 +281,36 @@ static bool balloon_is_inflated(void)
 
 static enum bp_state reserve_additional_memory(long credit)
 {
+	struct resource *resource;
 	int nid, rc;
-	u64 hotplug_start_paddr;
 	unsigned long balloon_hotplug = credit;
 
-	hotplug_start_paddr = PFN_PHYS(SECTION_ALIGN_UP(max_pfn));
 	balloon_hotplug = round_up(balloon_hotplug, PAGES_PER_SECTION);
-	nid = memory_add_physaddr_to_nid(hotplug_start_paddr);
 
-	rc = add_memory(nid, hotplug_start_paddr, balloon_hotplug << PAGE_SHIFT);
+	resource = additional_memory_resource(balloon_hotplug * PAGE_SIZE);
+	if (!resource)
+		goto err;
 
+	nid = memory_add_physaddr_to_nid(resource->start);
+	rc = add_memory_resource(nid, resource);
 	if (rc) {
 		pr_info("xen_balloon: %s: add_memory() failed: %i\n", __func__, rc);
-		return BP_EAGAIN;
+		goto err;
 	}
 
-	balloon_hotplug -= credit;
+	balloon_nr_hotplug_pages += balloon_hotplug;
 
-	balloon_stats.hotplug_pages += credit;
-	balloon_stats.balloon_hotplug = balloon_hotplug;
+    balloon_stats.balloon_hotplug += balloon_hotplug;
+	mutex_unlock(&balloon_mutex);
+	wait_event_interruptible(balloon_online_wq,
+				 balloon_nr_hotplug_pages == balloon_nr_online_pages);
+	mutex_lock(&balloon_mutex);
 
 	return BP_DONE;
+
+  err:
+	release_memory_resource(resource);
+	return BP_ECANCELED;
 }
 
 static void xen_online_page(struct page *page)
@@ -266,10 +321,9 @@ static void xen_online_page(struct page *page)
 
 	__balloon_append(page);
 
-	if (balloon_stats.hotplug_pages)
-		--balloon_stats.hotplug_pages;
-	else
-		--balloon_stats.balloon_hotplug;
+	balloon_nr_online_pages++;
+	if (balloon_nr_hotplug_pages == balloon_nr_online_pages)
+		wake_up(&balloon_online_wq);
 
 	mutex_unlock(&balloon_mutex);
 }
@@ -325,15 +379,6 @@ static enum bp_state increase_reservation(unsigned long nr_pages)
 		.domid        = DOMID_SELF
 	};
 
-#ifdef CONFIG_XEN_BALLOON_MEMORY_HOTPLUG
-	if (!balloon_stats.balloon_low && !balloon_stats.balloon_high) {
-		nr_pages = min(nr_pages, balloon_stats.balloon_hotplug);
-		balloon_stats.hotplug_pages += nr_pages;
-		balloon_stats.balloon_hotplug -= nr_pages;
-		return BP_DONE;
-	}
-#endif
-
 	if (nr_pages > ARRAY_SIZE(frame_list))
 		nr_pages = ARRAY_SIZE(frame_list);
 
@@ -397,15 +442,6 @@ static enum bp_state decrease_reservation(unsigned long nr_pages, gfp_t gfp)
 		.domid        = DOMID_SELF
 	};
 
-#ifdef CONFIG_XEN_BALLOON_MEMORY_HOTPLUG
-	if (balloon_stats.hotplug_pages) {
-		nr_pages = min(nr_pages, balloon_stats.hotplug_pages);
-		balloon_stats.hotplug_pages -= nr_pages;
-		balloon_stats.balloon_hotplug += nr_pages;
-		return BP_DONE;
-	}
-#endif
-
 	if (nr_pages > ARRAY_SIZE(frame_list))
 		nr_pages = ARRAY_SIZE(frame_list);
 
@@ -522,7 +558,8 @@ void balloon_set_new_target(unsigned long target)
 EXPORT_SYMBOL_GPL(balloon_set_new_target);
 
 /**
- * alloc_xenballooned_pages - get pages that have been ballooned out
+ * alloc_xenballooned_pages - get pages that have been ballooned out or reserve
+ * additional memory via hotplugging.
  * @nr_pages: Number of pages to get
  * @pages: pages returned
  * @highmem: allow highmem pages
@@ -531,8 +568,13 @@ EXPORT_SYMBOL_GPL(balloon_set_new_target);
 int alloc_xenballooned_pages(int nr_pages, struct page **pages, bool highmem)
 {
 	int pgno = 0;
-	struct page *page;
+	struct page *page = NULL;
 	mutex_lock(&balloon_mutex);
+    /* If balloon is empty, dont decrease dom0 memory.First try to hotplug memory. 
+     * Calculate how many more pages are required.
+     */
+    if (nr_pages > (balloon_stats.balloon_high + balloon_stats.balloon_low))
+        balloon_set_new_target(balloon_stats.current_pages + nr_pages);
 	while (pgno < nr_pages) {
 		page = balloon_retrieve(highmem);
 		if (page && (highmem || !PageHighMem(page))) {
@@ -661,9 +703,6 @@ static int __init balloon_init(void)
 	balloon_stats.max_retry_count = RETRY_UNLIMITED;
 
 #ifdef CONFIG_XEN_BALLOON_MEMORY_HOTPLUG
-	balloon_stats.hotplug_pages = 0;
-	balloon_stats.balloon_hotplug = 0;
-
 	set_online_page_callback(&xen_online_page);
 	register_memory_notifier(&xen_memory_nb);
 #endif
